# Chap 01: 오브젝트와 의존관계

### 1.4.3 제어권의 이전을 통한 제어관계 역전
#### 일반적인 프로그램 흐름
- 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장. 
- 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조.

#### 제어의 역전
- 일반적인 제어 흐름의 개념을 거꾸로 뒤집는 것.
- 오브젝트는 자신이 사용할 오브젝트를 스스로 선택/생성하지 않음.
- 자신이 어떻게 만들어지고 어디서 사용되는지를 알 수 없음.
- 모든 제어 권한을 다른 대상에게 위임하기에 위와 같은 현상 발생.

#### 라이브러리와 프레임워크의 차이(p93)
* 라이브러리: 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어함.
* 프레임워크: 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용됨.
  - 애플리케이션은 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 함.
  
IoC에선 프레임워크 또는 컨테이너같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요.

스프링은 IoC를 모든 기능의 기초가 되는 기반 기술로 삼고 있고, IoC를 극한까지 적용하고 있는 프레임워크.


## 1.5 스프링의 IoC

* 라이브러리 추가 필요
  - com.springsource.net.sf.cglib-2.2.0.jar
  - com.springsource.org.apache.commons.logging-1.1.1.jar
  - org.springframework.asm-3.0.7.RELEASE.jar
  - org.springframework.beans-3.0.7.RELEASE.jar
  - org.springframework.context-3.0.7.RELEASE.jar
  - org.springframework.core-3.0.7.RELEASE.jar
  - org.springframework.expression-3.0.7.RELEASE.jar

### 1.5.3 스프링 IoC의 용어 정리
* bean: 스프링이 (IoC 방식으로) 직접 그 생성과 제어를 담당하는 오브젝트
* bean factory: 스프링의 IoC를 담당하는 핵심 컨테이너.
* application context: 빈 팩토리를 확장한 IoC 컨테이너.
* configuration metadata: application context or bean factory가 IoC를 적용하기 위해 사용하는 메타정보
* IoC container: IoC방식으로 빈을 관리한다는 의미에서 application context or bean factory를 이렇게 부름. 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에 보통 여러 개가 만들어져 사용됨(이를 통틀어 스프링 컨테이너라고 부름)
* spring framework: IoC container, application context를 포함한 스프링이 제공하는 모든 기능을 통틀어 말할 때 사용.
  

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
ApplicationContext는 IoC container이기도 하면서 동시에 Singleton Registry이기도 함.

스프링은 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 싱글톤으로 만듬.

* 하지만 자바에서 구현하는 싱글톤을 그대로 사용하진 않음.
  - private 생성자를 가지고 있어 상속할 수 없음.
  - 테스트하기 힘듬.
  - 서버 배포 환경에서 단일 객체임을 보장 못함.
  - 전역 상태 안좋음.

* 스프링의 싱글톤 레지스트리는 평범한 자바 클래스도 IoC container를 이용해서 생성, 관계설정, 사용에 대한 제어권을 컨테이너에게 넘기기에 싱글톤 방식으로 만들어져 관리할 수 있음.

### 1.6.2 싱글톤과 오브젝트의 상태
싱글톤이 멀티스레드 환경에서 사용되는 경우 stateless 방식으로 만들어져야함.(각 스레드들이 데이터를 공유 못하도록)
- 개별적으로 바뀌는 정보는 데이터의 전역 공유를 막기 위해서 method parameter, local variables를 이용하면 싱글톤 내에서 필요한 데이터를 바르게 저장할 수 있음.


### 1.6.3 스프링 빈의 스코프
* scope: 빈이 생성되고, 존재하고, 적용되는 범위

- 기본 스코프: singleton
- prototype: 컨테이너가 빈을 요청할 때마다 새로운 오브젝트 생성
- request: http 요청이 생길때마다 생성되는
- session: 웹의 세션과 유사함.


## 1.7 Dependency Injection (DI; 의존관계 주입)
### 1.7.1 IoC와 DI
- 스프링 IoC 기능의 대표적인 동작원리는 주로 DI로 불림.  
- DI의 핵심은 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 dynamic하게 의존관계가 만들어지는 것.


### 1.7.2 런타임 의존관계 설정
자바에서 오브젝트에 무언가를 넣어준다는 개념은 메소드를 실행하면서 파라미터로 오브젝트의 레퍼런스를 전달해주눈 방법뿐임.

### 1.7.3 Dependency Lookup
- 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾음.
- 물론 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트 생성작업은 IoC Container에게 맡김.
- 다만 이를 가져올 때 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법
- static method에선 DI를 이용해 오브젝트를 주입받을 방법이 없음.
  - 그래서 애플리케이션 의 기둥 시점에선 적어도 한번은 DL 방식을 사용해 오브젝트를 가져와야 함.

* 하지만 DI가 단순 하고 깔끔함.
  - DL은 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타남.

* DL 방식에선 검색하는 오브젝트는 자신이 스프링의 bean일 필요가 없음.

* **DI를 원하는 오브젝트는 먼저 자기 자신이 Container가 관리하는 bean이 돼야 함.**
* DI받는 메소드 파라미터가 특정 클래스 타입으로 고정되어 있다면 DI는 일어날 수 없음. 
  - DI의 주입은 다이나믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터페이스 타입의 파라미터를 통해 이뤄져야 함.
